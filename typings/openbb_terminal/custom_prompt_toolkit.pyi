"""
This type stub file was generated by pyright.
"""

from typing import Any, Callable, Dict, Iterable, List, Mapping, Optional, Pattern, Set, Union
from prompt_toolkit.completion import CompleteEvent, Completer, Completion
from prompt_toolkit.document import Document
from prompt_toolkit.formatted_text import AnyFormattedText

""" Nestedcompleter for completion of OpenBB hierarchical data structures. """
NestedDict = Mapping[str, Union[Any, Set[str], None, Completer]]
class WordCompleter(Completer):
    """
    Simple autocompletion on a list of words.

    :param words: List of words or callable that returns a list of words.
    :param ignore_case: If True, case-insensitive completion.
    :param meta_dict: Optional dict mapping words to their meta-text. (This
        should map strings to strings or formatted text.)
    :param WORD: When True, use WORD characters.
    :param sentence: When True, don't complete by comparing the word before the
        cursor, but by comparing all the text before the cursor. In this case,
        the list of words is just a list of strings, where each string can
        contain spaces. (Can not be used together with the WORD option.)
    :param match_middle: When True, match not only the start, but also in the
                         middle of the word.
    :param pattern: Optional compiled regex for finding the word before
        the cursor to complete. When given, use this regex pattern instead of
        default one (see document._FIND_WORD_RE)
    """
    def __init__(self, words: Union[List[str], Callable[[], List[str]]], ignore_case: bool = ..., display_dict: Optional[Mapping[str, AnyFormattedText]] = ..., meta_dict: Optional[Mapping[str, AnyFormattedText]] = ..., WORD: bool = ..., sentence: bool = ..., match_middle: bool = ..., pattern: Optional[Pattern[str]] = ...) -> None:
        ...
    
    def get_completions(self, document: Document, _complete_event: CompleteEvent) -> Iterable[Completion]:
        ...
    


class NestedCompleter(Completer):
    """
    Completer which wraps around several other completers, and calls any the
    one that corresponds with the first word of the input.

    By combining multiple `NestedCompleter` instances, we can achieve multiple
    hierarchical levels of autocompletion. This is useful when `WordCompleter`
    is not sufficient.

    If you need multiple levels, check out the `from_nested_dict` classmethod.
    """
    complementary: List = ...
    def __init__(self, options: Dict[str, Optional[Completer]], ignore_case: bool = ...) -> None:
        ...
    
    def __repr__(self) -> str:
        ...
    
    @classmethod
    def from_nested_dict(cls, data: dict) -> NestedCompleter:
        """
        Create a `NestedCompleter`, starting from a nested dictionary data
        structure, like this:

        .. code::

            data = {
                'show': {
                    'version': None,
                    'interfaces': None,
                    'clock': None,
                    'ip': {'interface': {'brief'}}
                },
                'exit': None
                'enable': None
            }

        The value should be `None` if there is no further completion at some
        point. If all values in the dictionary are None, it is also possible to
        use a set instead.

        Values in this data structure can be a completers as well.
        """
        ...
    
    def get_completions(self, document: Document, complete_event: CompleteEvent) -> Iterable[Completion]:
        ...
    


